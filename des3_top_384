// =====================================================
//  des3_top_384.v  : 3DES cho 6 block 64-bit (384 bit)
//  - Nhận plaintext_in_384 (6×64)
//  - Tự tách thành 6 block 64-bit, lần lượt đưa vào des3_top
//  - Gom kết quả mã hóa & giải mã thành 384 bit
// =====================================================
module des3_top_384 (
    input          clock,
    input          rst,
    input          start,
    input  [63:0]  key0,
    input  [63:0]  key1,
    input  [63:0]  key2,
    input  [383:0] plaintext_in_384,   // 6 block 64-bit

    output reg [383:0] ciphertext_384, // 6 block cipher ghép lại
    output reg [383:0] recovered_384,  // 6 block decode ghép lại
    output reg         done_all        // xong cả 6 block
);

    // ================================================
    // Lưu plaintext 384-bit + chỉ số block
    // ================================================
    reg [383:0] pt_reg;
    reg [2:0]   blk_idx;      // 0..5

    reg [63:0]  cur_plain;

    // chọn block hiện tại để đưa vào des3_top
    always @(*) begin
        case (blk_idx)
            3'd0: cur_plain = pt_reg[383:320]; // block 0
            3'd1: cur_plain = pt_reg[319:256]; // block 1
            3'd2: cur_plain = pt_reg[255:192]; // block 2
            3'd3: cur_plain = pt_reg[191:128]; // block 3
            3'd4: cur_plain = pt_reg[127:64];  // block 4
            3'd5: cur_plain = pt_reg[63:0];    // block 5
            default: cur_plain = 64'd0;
        endcase
    end

    // ================================================
    // Instance 3DES 64-bit (encrypt + decrypt)
    // ================================================
    reg  inner_start;
    wire inner_done;
    wire [63:0] inner_cipher;
    wire [63:0] inner_recovered;

    des3_top u_block (
        .clock         (clock),
        .rst           (rst),
        .start         (inner_start),
        .key0          (key0),
        .key1          (key1),
        .key2          (key2),
        .plaintext_in  (cur_plain),
        .ciphertext_out(inner_cipher),
        .recovered_out (inner_recovered),
        .done_all      (inner_done)
    );

    // ================================================
    // FSM điều khiển các block
    // ================================================
    localparam S_IDLE = 2'd0;
    localparam S_RUN  = 2'd1;
    localparam S_DONE = 2'd2;

    reg [1:0] state;

    always @(posedge clock or posedge rst) begin
        if (rst) begin
            state          <= S_IDLE;
            blk_idx        <= 3'd0;
            inner_start    <= 1'b0;
            pt_reg         <= 384'd0;
            ciphertext_384 <= 384'd0;
            recovered_384  <= 384'd0;
            done_all       <= 1'b0;
        end else begin
            // mặc định mỗi clock
            inner_start <= 1'b0;
            done_all    <= 1'b0;

            case (state)
                // --------------------------
                S_IDLE: begin
                    if (start) begin
                        // chốt plaintext 384-bit
                        pt_reg  <= plaintext_in_384;
                        blk_idx <= 3'd0;

                        // kích block đầu
                        inner_start <= 1'b1;
                        state       <= S_RUN;
                    end
                end

                // --------------------------
                S_RUN: begin
                    if (inner_done) begin
                        // lưu kết quả block hiện tại
                        case (blk_idx)
                            3'd0: begin
                                ciphertext_384[383:320] <= inner_cipher;
                                recovered_384 [383:320] <= inner_recovered;
                            end
                            3'd1: begin
                                ciphertext_384[319:256] <= inner_cipher;
                                recovered_384 [319:256] <= inner_recovered;
                            end
                            3'd2: begin
                                ciphertext_384[255:192] <= inner_cipher;
                                recovered_384 [255:192] <= inner_recovered;
                            end
                            3'd3: begin
                                ciphertext_384[191:128] <= inner_cipher;
                                recovered_384 [191:128] <= inner_recovered;
                            end
                            3'd4: begin
                                ciphertext_384[127:64]  <= inner_cipher;
                                recovered_384 [127:64]  <= inner_recovered;
                            end
                            3'd5: begin
                                ciphertext_384[63:0]    <= inner_cipher;
                                recovered_384 [63:0]    <= inner_recovered;
                            end
                        endcase

                        // kiểm tra đã xong block cuối chưa
                        if (blk_idx == 3'd5) begin
                            done_all <= 1'b1;   // xong 6 block
                            state    <= S_DONE;
                        end else begin
                            blk_idx     <= blk_idx + 1'b1;
                            inner_start <= 1'b1; // kích block kế tiếp
                            // state vẫn ở S_RUN
                        end
                    end
                end

                // --------------------------
                S_DONE: begin
                    // chờ start về 0 rồi quay lại IDLE
                    if (!start)
                        state <= S_IDLE;
                end

            endcase
        end
    end

endmodule
